<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication & Authorisation</title>
    <link href='http://fonts.googleapis.com/css?family=Enriqueta' rel='stylesheet' type='text/css'>
    <script type="text/javascript" src="//use.typekit.net/itm5ubu.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link rel="stylesheet" href="/css/foundation.css" />
    <link rel="stylesheet" href="/css/capistrano.css">
    <link rel="stylesheet" href="/css/social_foundicons.css" />
    <link rel="stylesheet" href="/css/okaidia.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <script src="/js/vendor/custom.modernizr.js"></script>
  </head>
  <body>

    <script type="text/javascript">
      var _gauges = _gauges || [];
      (function() {
        var t   = document.createElement('script');
        t.type  = 'text/javascript';
        t.async = true;
        t.id    = 'gauges-tracker';
        t.setAttribute('data-site-id', '51c83c32613f5d7df70000bc');
        t.src = '//secure.gaug.es/track.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(t, s);
      })();
    </script>

    <script type="text/javascript">
      setTimeout(function(){var a=document.createElement("script");
      var b=document.getElementsByTagName("script")[0];
      a.src=document.location.protocol+"//dnn506yrbagrg.cloudfront.net/pages/scripts/0017/6418.js?"+Math.floor(new Date().getTime()/3600000);
      a.async=true;a.type="text/javascript";b.parentNode.insertBefore(a,b)}, 1);
    </script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41970098-1', 'capistranorb.com');
      ga('send', 'pageview');
    </script>
    <div class="header">
  <div class="row">
    <div class="large-12 column">
      <a href="/" class="brand">
        <img src="/images/CapistranoLogo.png" />
      </a>
    </div>
  </div>
</div>


    <div class="row">
      <div class="large-4 columns">
        <ul class="side-nav">
  <li><a href="https://www.harrow.io/" class="advertisment"><span class="label label-important">New</span> Hosted Capistrano for Teams</a></li>
  <li class="divider"></li>
  <h5>Overview</h5>
  <li><a href="/documentation/overview/what-is-capistrano/">What is Capistrano?</a></li>
  <!--<li><a href="/documentation/overview/introductory-demo-video/">Introductory Demo Video</a></li>-->
  <li class="divider"></li>
  <h5>Getting Started</h5>
  <li><a href="https://github.com/capistrano/capistrano/blob/master/README.md">The Readme, start here!</a></li>
  <li><a href="/documentation/getting-started/installation/">Installation</a></li>
  <li><a href="/documentation/getting-started/preparing-your-application/">Preparing Your Application</a></li>
  <li><a href="/documentation/getting-started/authentication-and-authorisation/">Authentication &amp; Authorisation</a></li>
  <li><a href="/documentation/getting-started/cold-start/">Cold Start</a></li>
  <li><a href="/documentation/getting-started/flow/">Flow</a></li>
  <li><a href="/documentation/getting-started/rollbacks/">Rollbacks</a></li>
  <li class="divider"></li>
  <h5>Advanced Features</h5>
  <li><a href="/documentation/advanced-features/ssh-kit">Remote commands with SSHKit</li>
  <li><a href="/documentation/advanced-features/remote-file/">Remote file task</a></li>
  <li><a href="/documentation/advanced-features/role-filtering/">Role filtering</a></li>
  <li><a href="/documentation/advanced-features/host-filtering/">Host filtering</a></li>
  <li><a href="/documentation/advanced-features/capistrano-pure-ruby/">Using Capistrano from pure Ruby</a></li>
  <li class="divider"></li>
  <h5>Framework Extensions</h5>
  <li><a href="/documentation/frameworks/ruby-on-rails/">Ruby on Rails</a></li>
  <li><a href="/documentation/frameworks/bundler/">Bundler</a></li>
  <li><a href="/documentation/frameworks/rbenv-rvm-chruby/">Rbenv &amp; RVM &amp; chruby</a></li>
  <!--<li class="divider"></li>                                                                     -->
  <!--<h5>Troubleshooting</h5>                                                                      -->
  <!--<li><a href="/documentation/troubleshooting/authentication/">SCM (Git) Authentication</a></li>-->
  <!--<li><a href="/documentation/troubleshooting/connectivity/">Connectivity</a></li>              -->
  <!--[><li><a href="/documentation/troubleshooting/gateway-servers/">Gateway Servers</a></li><]    -->
  <!--<li><a href="/documentation/troubleshooting/agent-forwarding/">Agent Forwarding</a></li>      -->
  <!--<li><a href="/documentation/troubleshooting/sudo-password/">`sudo` Password</a></li>          -->
  <!--<li><a href="/documentation/troubleshooting/rvm-rbenv-nvm/">RVM, `rbenv` And `nvm`</a></li>   -->
  <li class="divider"></li>
  <h5>FAQ</h5>
  <li><a href="/documentation/faq/why-does-something-work-in-my-ssh-session-but-not-in-capistrano/">Why Does Something Work In An SSH Session, But Not In Capistrano?</a></li>
  <!--<li><a href="/documentation/faq/should-i-use-capistrano-to-provision-my-servers/">Should I Use Capistrano To Provision My Servers?</a></li>-->
  <li><a href="http://lee.hambley.name/2013/06/11/using-capistrano-v3-with-chef.html">Should I Use Capistrano To Provision My Servers?</a></li>
  <!--<li class="divider"></li>                                                                                                      -->
  <!--<h5>Power Use-Cases</h5>                                                                                                       -->
  <!--<li><a href="/documentation/power-use-cases/integration-with-rake/">Integration With Rake</a></li>                             -->
  <!--<li><a href="/documentation/power-use-cases/driving-tools-such-as-chef-solo/">Driving Tools Such As <em>Chef Solo</em></a></li>-->
  <li class="divider"></li>
  <h5>Legacy Documentation</h5>
  <li><a href="https://github.com/capistrano/capistrano/wiki">Capistrano
    v2</a></li>
  <li class="divider"></li>
  <h5>Recent Announcements</h5>
  
    <li><a href="/2013/06/01/release-announcement.html"><span class="post-date">01 Jun 2013</span> Capistrano Version 3 Release Announcement</a></li>
  
</ul>

      </div>
      <div class="large-8 column">
        <div class="content">
          <h2>Authentication & Authorisation</h2>
          <p><strong>Note:</strong> In the documentation we simply recommend creating a single deployment user,
and sharing it between team members. If you know why this is a bad idea (or
why this may be against regulations in your jurisdiction in some cases, we
assume that you know well enough how to use groups, umasking and setgid bits
to make this work reliably for unique logins across team members)</p>

<p>To create this deploy user we&#39;ll assume something like the following has been
done:</p>

<div class="highlight"><pre><code class="bash">    root@remote <span class="nv">$Â </span>adduser deploy
    root@remote <span class="nv">$ </span>passwd -l deploy
</code></pre></div>

<p>The first line creates a completely standard user, it has a home directory,
which we&#39;ll need in a moment, and has a shell, so it may log in. This needs to
be done <strong>on every server in your environment</strong>.</p>

<p>The second line <em>locks</em> the user, it changes the user&#39;s password to an
untypable string, guaranteeing that the user has no password which can be used
to log in.</p>

<h3 id="toc_0">Authentication</h3>

<p>There are two places that we need automated, promptless authentication:</p>

<ol>
<li><strong>From our workstation/notebook/etc to our servers.</strong> We do this with <strong>SSH
 keys</strong>, passphrase protected, ideally, using a <strong>key agent</strong>.</li>
<li><strong>From our servers to the repository host</strong>. We do this so that our servers
 can check out our application code from Github, or similar and install it
 to the servers. This is usually done using <strong>SSH agent forwarding</strong>, HTTP
 authentication, or with deploy keys.</li>
</ol>

<h4 id="toc_1">1.1 SSH keys from workstation to servers</h4>

<p><strong>Note:</strong> If you are on Windows, all bets are off. I&#39;d love it if someone
could contribute a Windows guide to this, so we can include it here.</p>

<p>An SSH key is a mechanism that allows a <em>public</em> half one key to be placed on
a server, when we want to authenticate with that server, our SSH client uses
the <strong>private</strong> part of that key to negotiate with the server, if the keys are
correct, we are allowed to login.</p>

<p>Then we need to create the key.</p>

<p><strong>Hint:</strong> If you have more than one developer in your team, they should all add their
public key to the <code>deploy</code> user&#39;s <code>authorized_keys</code> file, that way if someone
quits or gets fired, you can remove their key from that file, and the rest of
you can keep on shipping!</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-keygen -t rsa -C <span class="s1">&#39;me@my_email_address.com&#39;</span>
</code></pre></div>

<p>You&#39;ll be prompted for a passphrase, that&#39;s fine. Type one and keep it safe.
This passphrase ensures that if your computer is stolen, people still need a
passphrase to access your keys, in order to access your servers.</p>

<p>To avoid having to type this passphrase every time you need to use a key, most
operating systems have a concept of a <em>key agent</em>. This <em>key agent</em> stores SSH
keys securely between uses, typically the first time a key is needed in a
given time period, the SSH agent will load the key, prompt you for your
passphrase and then the key agent will remember the key for a certain amount
of time (on OSX it tends to be indefinite, on linux this can vary from 15
minutes upwards.)</p>

<p>We can see which keys are loaded in the SSH agent by running <code>ssh-add -l</code></p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add -l
    2048 af:ce:7e:c5:93:18:39:ff:54:20:7a:2d:ec:05:7c:a5 /Users/me/.ssh/id_rsa <span class="o">(</span>RSA<span class="o">)</span>
</code></pre></div>

<p>If you don&#39;t see any keys listed, you can simply run <code>ssh-add</code>:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add
    Identity added: /Users/me/.ssh/id_rsa <span class="o">(</span>/Users/me/.ssh/id_rsa<span class="o">)</span>
</code></pre></div>

<p>Typically, ssh-add will ask you for the passphrase when you add a key.</p>

<p><strong>Note:</strong> Although it&#39;s not mandatory to use an SSH agent (one could simply
use an unpassphrased key, and rely on SSH to find the key and exchange it).
Using an SSH agent makes things more secure, because we can use a passphrased
key without being prompts every time it is used. It <strong>also</strong> allows us to use
this same key to access the repository <em>via</em> the server without creating an
additional identity.</p>

<p>At this point with the key loaded into the agent, we need to put the
<strong>public</strong> part of the key into a file on each remote server called
<code>/home/users/deploy/.ssh/authorized_keys</code>, to get the contents of that file,
we can ask our local key agent for the public parts of the keys it has loaded:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add -L
    ssh-rsa jccXJ/JRfGxnkh/8iL........dbfCH/9cDiKa0Dw8XGAo01mU/w<span class="o">==</span> /Users/me/.ssh/id_rsa
</code></pre></div>

<p>This will be a lot longer when you run it, I snipped the output because it
looked bad.</p>

<p>This line, as one line, needs to make it to the remote server and be added <em>to
it&#39;s own line</em> of the <code>deploy</code> user&#39;s <code>~/.ssh/authorized_keys</code> file. This file
then needs to be changed to permission mode <code>0600</code> (owner read/write, group
none, other none), in the <code>~/.ssh</code> directory which needs the permissions
<code>0700</code> (owner read/write/execute, group none, other none).</p>

<p>If you are on linux there often exists a command
<a href="http://linux.die.net/man/1/ssh-copy-id"><code>ssh-copy-id</code></a> which streamlines this
process, otherwise the workflow is something like:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh root@remote
    root@remote <span class="nv">$ </span>su - deploy
    deploy@remote <span class="nv">$ </span><span class="nb">cd</span> ~
    deploy@remote <span class="nv">$ </span>mkdir .ssh
    deploy@remote <span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;ssh-rsa jccXJ/JRfGxnkh/8iL........dbfCH/9cDiKa0Dw8XGAo01mU/w== /Users/me/.ssh/id_rsa&quot;</span> &gt;&gt; .ssh/authorized_keys
    deploy@remote <span class="nv">$ </span>chmod 700 .ssh
    deploy@remote <span class="nv">$ </span>chmod 600 .ssh/authorized_keys
</code></pre></div>

<p><strong>Remember:</strong> This needs to be done on every server you want to use, you can
use the same key for each one, but only one key per developer is recommended.
<em>Private</em> keys are named as such for a reason!</p>

<p>If we did all that correctly, we should now be able to do something like this:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh deploy@one-of-my-servers.com <span class="s1">&#39;hostname; uptime&#39;</span>
    one-of-my-servers.com
    19:23:32 up 62 days, 44 min, 1 user, load average: 0.00, 0.01, 0.05
</code></pre></div>

<p>That should happen without having to enter a passphrase for your SSH key, or
prompting you for an SSH password (which the deploy user doesn&#39;t have anyway).</p>

<p>Verify that this works for all of your servers, and put your private key
somewhere safe. If you&#39;re working with multiple team members, it often pays to
collect everyone&#39;s public keys, indeed if your team is already using SSH keys
to access Github, you can reach any user&#39;s SSH keys at the following URL:</p>

<ul>
<li><code>https://github.com/theirusername.keys</code></li>
</ul>

<p>This can make getting user&#39;s keys onto servers much easier, as you can simply
<code>curl</code>/<code>wget</code> each user&#39;s key into the authorized keys file on the server
directly from Github.</p>

<blockquote class="twitter-tweet"><p>TIL <a
href="https://twitter.com/github">@github</a> exposes the ssh public keys for
users. <a href="https://t.co/Wo9g8nxI">https://t.co/Wo9g8nxI</a> Handy for
adding devs to servers/repos.</p>&mdash; Postmodern (@postmodern_mod3) <a
href="https://twitter.com/postmodern_mod3/statuses/300438256200339456">February
10, 2013</a></blockquote>

<script async src="//platform.twitter.com/widgets.js"
charset="utf-8"></script>

<p>If your server isn&#39;t accessible directly and you need to use the SSH
ProxyCommand option, you should do</p>

<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;net/ssh/proxy/command&#39;</span>

<span class="n">set</span> <span class="ss">:ssh_options</span><span class="p">,</span> <span class="ss">proxy</span><span class="p">:</span> <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh mygateway.com -W %h:%p&#39;</span><span class="p">)</span>

<span class="c1"># OR</span>

<span class="n">server</span> <span class="s1">&#39;internal-hostname&#39;</span><span class="p">,</span>
  <span class="n">ssh_options</span><span class="p">:</span> <span class="p">{</span>
    <span class="ss">proxy</span><span class="p">:</span> <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh mygateway.com -W %h:%p&#39;</span><span class="p">),</span>
  <span class="p">}</span>
</code></pre></div>

<h4 id="toc_2">1.2 From our servers to the repository host</h4>

<p>With access from workstations to the servers settled, there is another hop to
contend with, which is letting the deploy user get access to the code
repository automatically. The options in order of preference:</p>

<h5 id="toc_3">1.2.1 SSH Agent Forwarding</h5>

<p>As we&#39;ve already set up an SSH agent, we can use the <em>agent forwarding</em>
feature of SSH to make this key agent available to further <em>hops</em>. In short,
we can use <strong>our own ssh key</strong> to authenticate ourselves from the server to
Github.</p>

<p>Here&#39;s how we can check if that works, first get the URL of the repository:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git config remote.origin.url
    git@github.com:capistrano/rails3-bootstrap-devise-cancan.git
</code></pre></div>

<p>Here we&#39;re listing our private (for testing purposes) fork of the
rails3-bootstrap-devise-cancan repository forked from the Rails Examples and
Tutorials project.</p>

<p>We can try to access the repository via our server by doing the following:</p>

<div class="highlight"><pre><code class="bash">    <span class="c">#Â List SSH keys that are loaded into the agent</span>
    me@localhost <span class="nv">$ </span>ssh-add -l
    <span class="c"># Make sure they key is loaded if &#39;ssh-add -l&#39; didn&#39;t show anything</span>
    me@localhost <span class="nv">$ </span>ssh-add
    me@localhost <span class="nv">$ </span>ssh -A deploy@one-of-my-servers.com <span class="err">&#39;</span>git ls-remote git@github.com:capistrano/rails3-bootstrap-devise-cancan.git
</code></pre></div>

<p>We first check that the agent has the keys loaded. If not we simply load it
and enter the passphrase when prompted.</p>

<p>Finally we use <code>ls-remote</code> from Git to list the remote objects, this is the
exact same check that Capistrano does internally before attempting to deploy.
The <code>-A</code> option may, or may not be required on your system, it&#39;s worth trying
it both ways just to know how your system treats agent forwarding by default.</p>

<p>If you get the error &quot;host key verification failed.&quot; log in into your server
and run as the deploy user the command <code>ssh git@github.com</code> to add github.com
to the list of known hosts.</p>

<p>From the SSH documentation:</p>

<div class="highlight"><pre><code class="bash">     -A  Enables forwarding of the authentication agent connection.  This can also be
         specified on a per-host basis in a configuration file.

         Agent forwarding should be enabled with caution.  Users with the ability to
         bypass file permissions on the remote host <span class="o">(</span><span class="k">for </span>the agent<span class="err">&#39;</span>s UNIX-domain
         socket<span class="o">)</span> can access the <span class="nb">local </span>agent through the forwarded connection.  An
         attacker cannot obtain key material from the agent, however they can perform
         operations on the keys that <span class="nb">enable </span>them to authenticate using the identities
         loaded into the agent.
</code></pre></div>

<p>In layman&#39;s terms, you shouldn&#39;t use SSH agent forwarding to machines where you
don&#39;t trust the administrators, as they can can override the permissions on
the system and use your keys as if they were you. That said, if you can&#39;t
trust your server administrators, perhaps they shouldn&#39;t have access to your
servers!</p>

<h5 id="toc_4">1.2.2 HTTP Authentication</h5>

<p>In the case of HTTP authentication <strong>be sure to use HTTPS</strong>, otherwise your
password will be sent in cleartext over the network, depending what your hosts
network infrastructure looks like that might be <em>very</em> bad news.</p>

<p>Typically when we try and list our remote objects, using the https method from
Github, we&#39;ll be prompted for a username and password:</p>

<h5 id="toc_5">1.2.2.1 With a regular username/password</h5>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://github.com/capistrano/rails3-bootstrap-devise-cancan.git
    Username <span class="k">for</span> <span class="s1">&#39;https://github.com&#39;</span>: myownusername
    Password <span class="k">for</span> <span class="s1">&#39;https://capistrano@github.com&#39;</span>:
</code></pre></div>

<p>This challenge response prompt doesn&#39;t work well for automating things, so
there are two ways to get around this depending on your server&#39;s host
operating system, the first is to use a <code>netrc</code> file, we won&#39;t talk about that
because the netrc is a global file that doesn&#39;t lend itself well to security.</p>

<p>The other mechanism, and the reason that its <strong>very</strong> important to always use
HTTPS not plain ol&#39; HTTP is to embed the username and password in the URL,
note this won&#39;t work well if your password has special characters:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://capistrano:ourverysecretpassword@github.com/capistrano/rails3-bootstrap-devise-cancan.git
    3419812c9f146d9a84b44bcc2c3caef94da54758HEAD
    3419812c9f146d9a84b44bcc2c3caef94da54758HEADrefs/heads/master
</code></pre></div>

<p>The bigger problem with passwords, whether inlined into the URL, or entered
into a <code>netrc</code> file, is that the password gives access to <strong>your entire Github
Account</strong> not just to one single repository.</p>

<h5 id="toc_6">1.2.2.2 With an OAuth Personal API Token</h5>

<p>This mechanism still gives access to <strong>every repository</strong> you can access, but
at Github, they recently rolled out a feature called <a href="https://github.com/blog/1509-personal-api-tokens">Personal API
Tokens</a> which allow you to
do something like this:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://.....................@github.com/capistrano/rails3-bootstrap-devise-cancan.git
    3419812c9f146d9a84b44bcc2c3caef94da54758HEAD
    3419812c9f146d9a84b44bcc2c3caef94da54758HEADrefs/heads/master
</code></pre></div>

<p>Where <code>....</code> is a personal API token, as such:</p>

<p><img src="/images/github-personal-api-token-page.png" alt="Github Personal API Token Page"></p>

<h5 id="toc_7">1.2.3 Deploy Keys</h5>

<p>Deploy keys, a feature of Github, and some other platforms allow you to
generate a <strong>second</strong> set of SSH keys for the connection between Github and
the servers themselves.</p>

<p>Slightly perversely in this case the public key is uploaded to the repository
host, and the private key must be copied to each server that you want to
deploy to.</p>

<p>Github has a quite excellent guide on this, much of which (unsurprisingly)
overlaps with the SSH key instructions above.</p>

<ul>
<li><a href="https://help.github.com/articles/managing-deploy-keys">Github Help: Managing Deploy Keys</a></li>
</ul>

<h3 id="toc_8">Authorisation</h3>

<p>The second part of this topic is that our deploy user needs to be authorised
to work in the deployment directory, on the server. That means we need to be
able to work, ideally without <code>sudo</code> (none of the default Capistrano recipes
expect <code>sudo</code> to be available), or for your custom recipes, you will need to
have configured <em>passwordless</em> <code>sudo</code>. Configuring <code>sudo</code> to give some users
access to come commands under some circumstances is beyond the scope of this
documentation, but sufficed to say something like:</p>

<div class="highlight"><pre><code class="bash">deploy <span class="nv">ALL</span><span class="o">=</span>NOPASSWD:/etc/init.d/mysqld, /etc/init.d/apache2
</code></pre></div>

<p>This example would give the user named <code>deploy</code> access to call <code>sudo
/etc/init.d/mysql _________</code> and the same for the <code>apache2</code> control script.</p>

<p><strong>Granting passwordless sudo should not be done lightly.</strong> It can be dangerous.
For example if an unprivileged user can <em>edit</em> the script that they can run
as root, they can easily edit it to do anything they want that is evil. Use
this carefully, and ideally architect your systems so that non-privileged
users can restart services, or that services restart <em>themselves</em> when they
notice a change.</p>

<p>To configure this hierarchy, ignoring for the moment the passwordless <code>sudo</code>
access that you may or may not need depending how well your servers are setup:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh root@remote
    <span class="c"># Capistrano will use /var/www/....... where ... is the value set in</span>
    <span class="c"># :application, you can override this by setting the &#39;:deploy_to&#39; variable</span>
    root@remote <span class="nv">$ deploy_to</span><span class="o">=</span>/var/www/rails3-bootstrap-devise-cancan-demo
    root@remote <span class="nv">$ </span>mkdir -p <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span>chown deploy:deploy <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span><span class="nb">umask </span>0002
    root@remote <span class="nv">$ </span>chmod g+s <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span>mkdir <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>/<span class="o">{</span>releases,shared<span class="o">}</span>
</code></pre></div>

<p><strong>Note:</strong> The <code>chmod g+s</code> is a really handy, and little known Unix feature, it
means that at the operating system level, without having to pay much attention
to the permissions at runtime, all files an directories created inside the
<code>${deploy_to}</code> directory will inherit the group ownership, that means in this
case even though we are root, the files will be created being owned by <code>root</code>
with the group <code>deploy</code>, the <code>umask 0002</code> ensures that the files created
<em>during this session</em> are created with the permissions <em>owner read/write,
group: read/write, other: none</em>. This means that we&#39;ll be able to read these
files from Apache, or our web server by running the web server in the <code>deploy</code>
group namespace.</p>

<div class="highlight"><pre><code class="bash">    root@remote <span class="c"># stat -c &quot;%A (%a) %n&quot; ${deploy_to}/</span>
    drwx--S--- <span class="o">(</span>2700<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo

    root@remote <span class="c"># stat -c &quot;%A (%a) %n&quot; ${deploy_to}/*</span>
    drwxrwsr-x <span class="o">(</span>2775<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo/releases
    drwxrwsr-x <span class="o">(</span>2775<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo/shared
</code></pre></div>

        </div>
      </div>
    </div>

    <!--<div class="container">                                     -->
      <!--      <h1 class="title"><a href="/">Capistrano</a></h1>-->
      <!--      <a class="extra" href="/">home</a>                    -->
      <!--    </div>                                                  -->

    <!--    <p><strong>Note:</strong> In the documentation we simply recommend creating a single deployment user,
and sharing it between team members. If you know why this is a bad idea (or
why this may be against regulations in your jurisdiction in some cases, we
assume that you know well enough how to use groups, umasking and setgid bits
to make this work reliably for unique logins across team members)</p>

<p>To create this deploy user we&#39;ll assume something like the following has been
done:</p>

<div class="highlight"><pre><code class="bash">    root@remote <span class="nv">$Â </span>adduser deploy
    root@remote <span class="nv">$ </span>passwd -l deploy
</code></pre></div>

<p>The first line creates a completely standard user, it has a home directory,
which we&#39;ll need in a moment, and has a shell, so it may log in. This needs to
be done <strong>on every server in your environment</strong>.</p>

<p>The second line <em>locks</em> the user, it changes the user&#39;s password to an
untypable string, guaranteeing that the user has no password which can be used
to log in.</p>

<h3 id="toc_0">Authentication</h3>

<p>There are two places that we need automated, promptless authentication:</p>

<ol>
<li><strong>From our workstation/notebook/etc to our servers.</strong> We do this with <strong>SSH
 keys</strong>, passphrase protected, ideally, using a <strong>key agent</strong>.</li>
<li><strong>From our servers to the repository host</strong>. We do this so that our servers
 can check out our application code from Github, or similar and install it
 to the servers. This is usually done using <strong>SSH agent forwarding</strong>, HTTP
 authentication, or with deploy keys.</li>
</ol>

<h4 id="toc_1">1.1 SSH keys from workstation to servers</h4>

<p><strong>Note:</strong> If you are on Windows, all bets are off. I&#39;d love it if someone
could contribute a Windows guide to this, so we can include it here.</p>

<p>An SSH key is a mechanism that allows a <em>public</em> half one key to be placed on
a server, when we want to authenticate with that server, our SSH client uses
the <strong>private</strong> part of that key to negotiate with the server, if the keys are
correct, we are allowed to login.</p>

<p>Then we need to create the key.</p>

<p><strong>Hint:</strong> If you have more than one developer in your team, they should all add their
public key to the <code>deploy</code> user&#39;s <code>authorized_keys</code> file, that way if someone
quits or gets fired, you can remove their key from that file, and the rest of
you can keep on shipping!</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-keygen -t rsa -C <span class="s1">&#39;me@my_email_address.com&#39;</span>
</code></pre></div>

<p>You&#39;ll be prompted for a passphrase, that&#39;s fine. Type one and keep it safe.
This passphrase ensures that if your computer is stolen, people still need a
passphrase to access your keys, in order to access your servers.</p>

<p>To avoid having to type this passphrase every time you need to use a key, most
operating systems have a concept of a <em>key agent</em>. This <em>key agent</em> stores SSH
keys securely between uses, typically the first time a key is needed in a
given time period, the SSH agent will load the key, prompt you for your
passphrase and then the key agent will remember the key for a certain amount
of time (on OSX it tends to be indefinite, on linux this can vary from 15
minutes upwards.)</p>

<p>We can see which keys are loaded in the SSH agent by running <code>ssh-add -l</code></p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add -l
    2048 af:ce:7e:c5:93:18:39:ff:54:20:7a:2d:ec:05:7c:a5 /Users/me/.ssh/id_rsa <span class="o">(</span>RSA<span class="o">)</span>
</code></pre></div>

<p>If you don&#39;t see any keys listed, you can simply run <code>ssh-add</code>:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add
    Identity added: /Users/me/.ssh/id_rsa <span class="o">(</span>/Users/me/.ssh/id_rsa<span class="o">)</span>
</code></pre></div>

<p>Typically, ssh-add will ask you for the passphrase when you add a key.</p>

<p><strong>Note:</strong> Although it&#39;s not mandatory to use an SSH agent (one could simply
use an unpassphrased key, and rely on SSH to find the key and exchange it).
Using an SSH agent makes things more secure, because we can use a passphrased
key without being prompts every time it is used. It <strong>also</strong> allows us to use
this same key to access the repository <em>via</em> the server without creating an
additional identity.</p>

<p>At this point with the key loaded into the agent, we need to put the
<strong>public</strong> part of the key into a file on each remote server called
<code>/home/users/deploy/.ssh/authorized_keys</code>, to get the contents of that file,
we can ask our local key agent for the public parts of the keys it has loaded:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh-add -L
    ssh-rsa jccXJ/JRfGxnkh/8iL........dbfCH/9cDiKa0Dw8XGAo01mU/w<span class="o">==</span> /Users/me/.ssh/id_rsa
</code></pre></div>

<p>This will be a lot longer when you run it, I snipped the output because it
looked bad.</p>

<p>This line, as one line, needs to make it to the remote server and be added <em>to
it&#39;s own line</em> of the <code>deploy</code> user&#39;s <code>~/.ssh/authorized_keys</code> file. This file
then needs to be changed to permission mode <code>0600</code> (owner read/write, group
none, other none), in the <code>~/.ssh</code> directory which needs the permissions
<code>0700</code> (owner read/write/execute, group none, other none).</p>

<p>If you are on linux there often exists a command
<a href="http://linux.die.net/man/1/ssh-copy-id"><code>ssh-copy-id</code></a> which streamlines this
process, otherwise the workflow is something like:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh root@remote
    root@remote <span class="nv">$ </span>su - deploy
    deploy@remote <span class="nv">$ </span><span class="nb">cd</span> ~
    deploy@remote <span class="nv">$ </span>mkdir .ssh
    deploy@remote <span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;ssh-rsa jccXJ/JRfGxnkh/8iL........dbfCH/9cDiKa0Dw8XGAo01mU/w== /Users/me/.ssh/id_rsa&quot;</span> &gt;&gt; .ssh/authorized_keys
    deploy@remote <span class="nv">$ </span>chmod 700 .ssh
    deploy@remote <span class="nv">$ </span>chmod 600 .ssh/authorized_keys
</code></pre></div>

<p><strong>Remember:</strong> This needs to be done on every server you want to use, you can
use the same key for each one, but only one key per developer is recommended.
<em>Private</em> keys are named as such for a reason!</p>

<p>If we did all that correctly, we should now be able to do something like this:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh deploy@one-of-my-servers.com <span class="s1">&#39;hostname; uptime&#39;</span>
    one-of-my-servers.com
    19:23:32 up 62 days, 44 min, 1 user, load average: 0.00, 0.01, 0.05
</code></pre></div>

<p>That should happen without having to enter a passphrase for your SSH key, or
prompting you for an SSH password (which the deploy user doesn&#39;t have anyway).</p>

<p>Verify that this works for all of your servers, and put your private key
somewhere safe. If you&#39;re working with multiple team members, it often pays to
collect everyone&#39;s public keys, indeed if your team is already using SSH keys
to access Github, you can reach any user&#39;s SSH keys at the following URL:</p>

<ul>
<li><code>https://github.com/theirusername.keys</code></li>
</ul>

<p>This can make getting user&#39;s keys onto servers much easier, as you can simply
<code>curl</code>/<code>wget</code> each user&#39;s key into the authorized keys file on the server
directly from Github.</p>

<blockquote class="twitter-tweet"><p>TIL <a
href="https://twitter.com/github">@github</a> exposes the ssh public keys for
users. <a href="https://t.co/Wo9g8nxI">https://t.co/Wo9g8nxI</a> Handy for
adding devs to servers/repos.</p>&mdash; Postmodern (@postmodern_mod3) <a
href="https://twitter.com/postmodern_mod3/statuses/300438256200339456">February
10, 2013</a></blockquote>

<script async src="//platform.twitter.com/widgets.js"
charset="utf-8"></script>

<p>If your server isn&#39;t accessible directly and you need to use the SSH
ProxyCommand option, you should do</p>

<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;net/ssh/proxy/command&#39;</span>

<span class="n">set</span> <span class="ss">:ssh_options</span><span class="p">,</span> <span class="ss">proxy</span><span class="p">:</span> <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh mygateway.com -W %h:%p&#39;</span><span class="p">)</span>

<span class="c1"># OR</span>

<span class="n">server</span> <span class="s1">&#39;internal-hostname&#39;</span><span class="p">,</span>
  <span class="n">ssh_options</span><span class="p">:</span> <span class="p">{</span>
    <span class="ss">proxy</span><span class="p">:</span> <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh mygateway.com -W %h:%p&#39;</span><span class="p">),</span>
  <span class="p">}</span>
</code></pre></div>

<h4 id="toc_2">1.2 From our servers to the repository host</h4>

<p>With access from workstations to the servers settled, there is another hop to
contend with, which is letting the deploy user get access to the code
repository automatically. The options in order of preference:</p>

<h5 id="toc_3">1.2.1 SSH Agent Forwarding</h5>

<p>As we&#39;ve already set up an SSH agent, we can use the <em>agent forwarding</em>
feature of SSH to make this key agent available to further <em>hops</em>. In short,
we can use <strong>our own ssh key</strong> to authenticate ourselves from the server to
Github.</p>

<p>Here&#39;s how we can check if that works, first get the URL of the repository:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git config remote.origin.url
    git@github.com:capistrano/rails3-bootstrap-devise-cancan.git
</code></pre></div>

<p>Here we&#39;re listing our private (for testing purposes) fork of the
rails3-bootstrap-devise-cancan repository forked from the Rails Examples and
Tutorials project.</p>

<p>We can try to access the repository via our server by doing the following:</p>

<div class="highlight"><pre><code class="bash">    <span class="c">#Â List SSH keys that are loaded into the agent</span>
    me@localhost <span class="nv">$ </span>ssh-add -l
    <span class="c"># Make sure they key is loaded if &#39;ssh-add -l&#39; didn&#39;t show anything</span>
    me@localhost <span class="nv">$ </span>ssh-add
    me@localhost <span class="nv">$ </span>ssh -A deploy@one-of-my-servers.com <span class="err">&#39;</span>git ls-remote git@github.com:capistrano/rails3-bootstrap-devise-cancan.git
</code></pre></div>

<p>We first check that the agent has the keys loaded. If not we simply load it
and enter the passphrase when prompted.</p>

<p>Finally we use <code>ls-remote</code> from Git to list the remote objects, this is the
exact same check that Capistrano does internally before attempting to deploy.
The <code>-A</code> option may, or may not be required on your system, it&#39;s worth trying
it both ways just to know how your system treats agent forwarding by default.</p>

<p>If you get the error &quot;host key verification failed.&quot; log in into your server
and run as the deploy user the command <code>ssh git@github.com</code> to add github.com
to the list of known hosts.</p>

<p>From the SSH documentation:</p>

<div class="highlight"><pre><code class="bash">     -A  Enables forwarding of the authentication agent connection.  This can also be
         specified on a per-host basis in a configuration file.

         Agent forwarding should be enabled with caution.  Users with the ability to
         bypass file permissions on the remote host <span class="o">(</span><span class="k">for </span>the agent<span class="err">&#39;</span>s UNIX-domain
         socket<span class="o">)</span> can access the <span class="nb">local </span>agent through the forwarded connection.  An
         attacker cannot obtain key material from the agent, however they can perform
         operations on the keys that <span class="nb">enable </span>them to authenticate using the identities
         loaded into the agent.
</code></pre></div>

<p>In layman&#39;s terms, you shouldn&#39;t use SSH agent forwarding to machines where you
don&#39;t trust the administrators, as they can can override the permissions on
the system and use your keys as if they were you. That said, if you can&#39;t
trust your server administrators, perhaps they shouldn&#39;t have access to your
servers!</p>

<h5 id="toc_4">1.2.2 HTTP Authentication</h5>

<p>In the case of HTTP authentication <strong>be sure to use HTTPS</strong>, otherwise your
password will be sent in cleartext over the network, depending what your hosts
network infrastructure looks like that might be <em>very</em> bad news.</p>

<p>Typically when we try and list our remote objects, using the https method from
Github, we&#39;ll be prompted for a username and password:</p>

<h5 id="toc_5">1.2.2.1 With a regular username/password</h5>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://github.com/capistrano/rails3-bootstrap-devise-cancan.git
    Username <span class="k">for</span> <span class="s1">&#39;https://github.com&#39;</span>: myownusername
    Password <span class="k">for</span> <span class="s1">&#39;https://capistrano@github.com&#39;</span>:
</code></pre></div>

<p>This challenge response prompt doesn&#39;t work well for automating things, so
there are two ways to get around this depending on your server&#39;s host
operating system, the first is to use a <code>netrc</code> file, we won&#39;t talk about that
because the netrc is a global file that doesn&#39;t lend itself well to security.</p>

<p>The other mechanism, and the reason that its <strong>very</strong> important to always use
HTTPS not plain ol&#39; HTTP is to embed the username and password in the URL,
note this won&#39;t work well if your password has special characters:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://capistrano:ourverysecretpassword@github.com/capistrano/rails3-bootstrap-devise-cancan.git
    3419812c9f146d9a84b44bcc2c3caef94da54758HEAD
    3419812c9f146d9a84b44bcc2c3caef94da54758HEADrefs/heads/master
</code></pre></div>

<p>The bigger problem with passwords, whether inlined into the URL, or entered
into a <code>netrc</code> file, is that the password gives access to <strong>your entire Github
Account</strong> not just to one single repository.</p>

<h5 id="toc_6">1.2.2.2 With an OAuth Personal API Token</h5>

<p>This mechanism still gives access to <strong>every repository</strong> you can access, but
at Github, they recently rolled out a feature called <a href="https://github.com/blog/1509-personal-api-tokens">Personal API
Tokens</a> which allow you to
do something like this:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>git ls-remote https://.....................@github.com/capistrano/rails3-bootstrap-devise-cancan.git
    3419812c9f146d9a84b44bcc2c3caef94da54758HEAD
    3419812c9f146d9a84b44bcc2c3caef94da54758HEADrefs/heads/master
</code></pre></div>

<p>Where <code>....</code> is a personal API token, as such:</p>

<p><img src="/images/github-personal-api-token-page.png" alt="Github Personal API Token Page"></p>

<h5 id="toc_7">1.2.3 Deploy Keys</h5>

<p>Deploy keys, a feature of Github, and some other platforms allow you to
generate a <strong>second</strong> set of SSH keys for the connection between Github and
the servers themselves.</p>

<p>Slightly perversely in this case the public key is uploaded to the repository
host, and the private key must be copied to each server that you want to
deploy to.</p>

<p>Github has a quite excellent guide on this, much of which (unsurprisingly)
overlaps with the SSH key instructions above.</p>

<ul>
<li><a href="https://help.github.com/articles/managing-deploy-keys">Github Help: Managing Deploy Keys</a></li>
</ul>

<h3 id="toc_8">Authorisation</h3>

<p>The second part of this topic is that our deploy user needs to be authorised
to work in the deployment directory, on the server. That means we need to be
able to work, ideally without <code>sudo</code> (none of the default Capistrano recipes
expect <code>sudo</code> to be available), or for your custom recipes, you will need to
have configured <em>passwordless</em> <code>sudo</code>. Configuring <code>sudo</code> to give some users
access to come commands under some circumstances is beyond the scope of this
documentation, but sufficed to say something like:</p>

<div class="highlight"><pre><code class="bash">deploy <span class="nv">ALL</span><span class="o">=</span>NOPASSWD:/etc/init.d/mysqld, /etc/init.d/apache2
</code></pre></div>

<p>This example would give the user named <code>deploy</code> access to call <code>sudo
/etc/init.d/mysql _________</code> and the same for the <code>apache2</code> control script.</p>

<p><strong>Granting passwordless sudo should not be done lightly.</strong> It can be dangerous.
For example if an unprivileged user can <em>edit</em> the script that they can run
as root, they can easily edit it to do anything they want that is evil. Use
this carefully, and ideally architect your systems so that non-privileged
users can restart services, or that services restart <em>themselves</em> when they
notice a change.</p>

<p>To configure this hierarchy, ignoring for the moment the passwordless <code>sudo</code>
access that you may or may not need depending how well your servers are setup:</p>

<div class="highlight"><pre><code class="bash">    me@localhost <span class="nv">$ </span>ssh root@remote
    <span class="c"># Capistrano will use /var/www/....... where ... is the value set in</span>
    <span class="c"># :application, you can override this by setting the &#39;:deploy_to&#39; variable</span>
    root@remote <span class="nv">$ deploy_to</span><span class="o">=</span>/var/www/rails3-bootstrap-devise-cancan-demo
    root@remote <span class="nv">$ </span>mkdir -p <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span>chown deploy:deploy <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span><span class="nb">umask </span>0002
    root@remote <span class="nv">$ </span>chmod g+s <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>
    root@remote <span class="nv">$ </span>mkdir <span class="k">${</span><span class="nv">deploy_to</span><span class="k">}</span>/<span class="o">{</span>releases,shared<span class="o">}</span>
</code></pre></div>

<p><strong>Note:</strong> The <code>chmod g+s</code> is a really handy, and little known Unix feature, it
means that at the operating system level, without having to pay much attention
to the permissions at runtime, all files an directories created inside the
<code>${deploy_to}</code> directory will inherit the group ownership, that means in this
case even though we are root, the files will be created being owned by <code>root</code>
with the group <code>deploy</code>, the <code>umask 0002</code> ensures that the files created
<em>during this session</em> are created with the permissions <em>owner read/write,
group: read/write, other: none</em>. This means that we&#39;ll be able to read these
files from Apache, or our web server by running the web server in the <code>deploy</code>
group namespace.</p>

<div class="highlight"><pre><code class="bash">    root@remote <span class="c"># stat -c &quot;%A (%a) %n&quot; ${deploy_to}/</span>
    drwx--S--- <span class="o">(</span>2700<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo

    root@remote <span class="c"># stat -c &quot;%A (%a) %n&quot; ${deploy_to}/*</span>
    drwxrwsr-x <span class="o">(</span>2775<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo/releases
    drwxrwsr-x <span class="o">(</span>2775<span class="o">)</span>  /var/www/rails3-bootstrap-devise-cancan-demo/shared
</code></pre></div>
                                           -->

    <!--</div> [> /container <]                                     -->

  <footer>
  <div class="row">
    <div class="large-4 columns">
      <ul>
      <li><a href="/documentation/overview/what-is-capistrano/">About Capistrano</a></li>
      <li><a href="https://github.com/capistrano/capistrano/blob/master/CONTRIBUTING.md">Contributing</a></li>
      <li><a href="https://rubygems.org/gems/capistrano/versions">Releases</a></li>
      </ul>
    </div>

    <div class="large-4 columns">
      <ul>
        <li><a href="http://stackoverflow.com/questions/tagged/capistrano">StackOverflow</a></li>
        <li><a href="https://groups.google.com/forum/#!forum/capistrano">Mailing List</a></li>
      </ul>
    </div>

    <div class="large-4 columns">
      <ul class="social icons">
        <li><a href="//twitter.com/capistranorb"><i class="foundicon-twitter"></i></a></li>
        <li><a href="//github.com/capistrano"><i class="foundicon-github"></i></a></li>
      </ul>
    </div>
  </div>
</footer>


  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
  <script>
    if (!window.jQuery) {
      document.write('<script src="/js/jquery-1.7.min"><\/script>');
    }
  </script>
  <script src="/js/jquery.githubRepoWidget.min.js"></script>
  <script src="/js/prism.js"></script>
  <script src="/js/prism.ruby.js"></script>
  <a href="https://github.com/capistrano/documentation"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>
</body>
</html>
